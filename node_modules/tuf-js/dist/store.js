"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrustedMetadataStore = void 0;
const models_1 = require("@tufjs/models");
const error_1 = require("./error");
class TrustedMetadataStore {
    constructor(rootData) {
        this.trustedSet = {};
        // Client workflow 5.1: record fixed update start time
        this.referenceTime = new Date();
        // Client workflow 5.2: load trusted root metadata
        this.loadTrustedRoot(rootData);
    }
    get root() {
        if (!this.trustedSet.root) {
            throw new ReferenceError('No trusted root metadata');
        }
        return this.trustedSet.root;
    }
    get timestamp() {
        return this.trustedSet.timestamp;
    }
    get snapshot() {
        return this.trustedSet.snapshot;
    }
    get targets() {
        return this.trustedSet.targets;
    }
    getRole(name) {
        return this.trustedSet[name];
    }
    updateRoot(bytesBuffer) {
        const data = JSON.parse(bytesBuffer.toString('utf8'));
        const newRoot = models_1.Metadata.fromJSON(models_1.MetadataKind.Root, data);
        if (newRoot.signed.type != models_1.MetadataKind.Root) {
            throw new error_1.RepositoryError(`Expected 'root', got ${newRoot.signed.type}`);
        }
        // Client workflow 5.4: check for arbitrary software attack
        this.root.verifyDelegate(models_1.MetadataKind.Root, newRoot);
        // Client workflow 5.5: check for rollback attack
        if (newRoot.signed.version != this.root.signed.version + 1) {
            throw new error_1.BadVersionError(`Expected version ${this.root.signed.version + 1}, got ${newRoot.signed.version}`);
        }
        // Check that new root is signed by self
        newRoot.verifyDelegate(models_1.MetadataKind.Root, newRoot);
        // Client workflow 5.7: set new root as trusted root
        this.trustedSet.root = newRoot;
        return newRoot;
    }
    updateTimestamp(bytesBuffer) {
        if (this.snapshot) {
            throw new error_1.RuntimeError('Cannot update timestamp after snapshot');
        }
        if (this.root.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError('Final root.json is expired');
        }
        const data = JSON.parse(bytesBuffer.toString('utf8'));
        const newTimestamp = models_1.Metadata.fromJSON(models_1.MetadataKind.Timestamp, data);
        if (newTimestamp.signed.type != models_1.MetadataKind.Timestamp) {
            throw new error_1.RepositoryError(`Expected 'timestamp', got ${newTimestamp.signed.type}`);
        }
        // Client workflow 5.4.2: check for arbitrary software attack
        this.root.verifyDelegate(models_1.MetadataKind.Timestamp, newTimestamp);
        if (this.timestamp) {
            // Prevent rolling back timestamp version
            // Client workflow 5.4.3.1: check for rollback attack
            if (newTimestamp.signed.version < this.timestamp.signed.version) {
                throw new error_1.BadVersionError(`New timestamp version ${newTimestamp.signed.version} is less than current version ${this.timestamp.signed.version}`);
            }
            //  Keep using old timestamp if versions are equal.
            if (newTimestamp.signed.version === this.timestamp.signed.version) {
                throw new error_1.EqualVersionError(`New timestamp version ${newTimestamp.signed.version} is equal to current version ${this.timestamp.signed.version}`);
            }
            // Prevent rolling back snapshot version
            // Client workflow 5.4.3.2: check for rollback attack
            const snapshotMeta = this.timestamp.signed.snapshotMeta;
            const newSnapshotMeta = newTimestamp.signed.snapshotMeta;
            if (newSnapshotMeta.version < snapshotMeta.version) {
                throw new error_1.BadVersionError(`New snapshot version ${newSnapshotMeta.version} is less than current version ${snapshotMeta.version}`);
            }
        }
        // expiry not checked to allow old timestamp to be used for rollback
        // protection of new timestamp: expiry is checked in update_snapshot
        this.trustedSet.timestamp = newTimestamp;
        // Client workflow 5.4.4: check for freeze attack
        this.checkFinalTimestamp();
        return newTimestamp;
    }
    updateSnapshot(bytesBuffer, trusted = false) {
        if (!this.timestamp) {
            throw new error_1.RuntimeError('Cannot update snapshot before timestamp');
        }
        if (this.targets) {
            throw new error_1.RuntimeError('Cannot update snapshot after targets');
        }
        // Snapshot cannot be loaded if final timestamp is expired
        this.checkFinalTimestamp();
        const snapshotMeta = this.timestamp.signed.snapshotMeta;
        // Verify non-trusted data against the hashes in timestamp, if any.
        // Trusted snapshot data has already been verified once.
        // Client workflow 5.5.2: check against timestamp role's snaphsot hash
        if (!trusted) {
            snapshotMeta.verify(bytesBuffer);
        }
        const data = JSON.parse(bytesBuffer.toString('utf8'));
        const newSnapshot = models_1.Metadata.fromJSON(models_1.MetadataKind.Snapshot, data);
        if (newSnapshot.signed.type != models_1.MetadataKind.Snapshot) {
            throw new error_1.RepositoryError(`Expected 'snapshot', got ${newSnapshot.signed.type}`);
        }
        // Client workflow 5.5.3: check for arbitrary software attack
        this.root.verifyDelegate(models_1.MetadataKind.Snapshot, newSnapshot);
        // version check against meta version (5.5.4) is deferred to allow old
        // snapshot to be used in rollback protection
        // Client workflow 5.5.5: check for rollback attack
        if (this.snapshot) {
            Object.entries(this.snapshot.signed.meta).forEach(([fileName, fileInfo]) => {
                const newFileInfo = newSnapshot.signed.meta[fileName];
                if (!newFileInfo) {
                    throw new error_1.RepositoryError(`Missing file ${fileName} in new snapshot`);
                }
                if (newFileInfo.version < fileInfo.version) {
                    throw new error_1.BadVersionError(`New version ${newFileInfo.version} of ${fileName} is less than current version ${fileInfo.version}`);
                }
            });
        }
        this.trustedSet.snapshot = newSnapshot;
        // snapshot is loaded, but we raise if it's not valid _final_ snapshot
        // Client workflow 5.5.4 & 5.5.6
        this.checkFinalSnapsnot();
        return newSnapshot;
    }
    updateDelegatedTargets(bytesBuffer, roleName, delegatorName) {
        if (!this.snapshot) {
            throw new error_1.RuntimeError('Cannot update delegated targets before snapshot');
        }
        // Targets cannot be loaded if final snapshot is expired or its version
        // does not match meta version in timestamp.
        this.checkFinalSnapsnot();
        const delegator = this.trustedSet[delegatorName];
        if (!delegator) {
            throw new error_1.RuntimeError(`No trusted ${delegatorName} metadata`);
        }
        // Extract metadata for the delegated role from snapshot
        const meta = this.snapshot.signed.meta?.[`${roleName}.json`];
        if (!meta) {
            throw new error_1.RepositoryError(`Missing ${roleName}.json in snapshot`);
        }
        // Client workflow 5.6.2: check against snapshot role's targets hash
        meta.verify(bytesBuffer);
        const data = JSON.parse(bytesBuffer.toString('utf8'));
        const newDelegate = models_1.Metadata.fromJSON(models_1.MetadataKind.Targets, data);
        if (newDelegate.signed.type != models_1.MetadataKind.Targets) {
            throw new error_1.RepositoryError(`Expected 'targets', got ${newDelegate.signed.type}`);
        }
        // Client workflow 5.6.3: check for arbitrary software attack
        delegator.verifyDelegate(roleName, newDelegate);
        // Client workflow 5.6.4: Check against snapshot roleâ€™s targets version
        const version = newDelegate.signed.version;
        if (version != meta.version) {
            throw nPK     ! ß¤ÒlZ      [Content_Types].xml ¢(                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ´”ËnÂ0E÷•ú‘·Ubè¢ª*‹>–-Ré{Vı’Ç¼ş¾QU‘
l"%3÷Ş3VÆƒÑÚšl	µw%ë=–“^i7+Ù×ä-d&á”0ŞAÉ6€l4¼½L60#µÃ’ÍS
Oœ£œƒXø *•V$z3„ü3à÷½Ş—Ş%p)Oµ^ “²×5}nH"dÙsÓXg•L„`´‰ê|éÔŸ”|—PrÛƒsğ?˜PWìtt4Q+ÈÆ"¦wa©‹¯|T\y¹°¤,NÛàôU¥%´úÚ-D/‘ÎÜš¢­X¡İÿ(¦¼<EãÛ)‘à ;çN„L?¯FñË¼¤¢Ü‰˜¸<Fkİ	‘h¡yöÏæØÚœŠ¤Îqôi£ã?ÆŞ¯l­Îià 1éÓ]›HÖgÏõm @ÈæÛûmø  ÿÿ PK     ! ‘·ï   N   _rels/.rels ¢(                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ¬’ÁjÃ0@ïƒıƒÑ½QÚÁ£N/cĞÛÙ[ILÛØj×şı<ØØ]éaGËÒÓ“ĞzsœFuà”]ğ–UŠ½	Öù^Ã[û¼x •…¼¥1xÖpâ›æöfıÊ#I)Êƒ‹YŠÏ‘øˆ˜ÍÀå*Döå§i")ÏÔc$³£qU×÷˜~3 ™1ÕÖjH[{ª=E¾†ºÎ~
f?±—3-ÂŞ²]ÄTê“¸2j)õ,l0/%œ‘b¬
ğ¼Ñêz£¿§Å‰…,	¡	‰/û|f\ZşçŠæ?6ï!Y´_áoœ]Aó  ÿÿ PK     ! ­ûåÅ  °     word/document.xml¤˜ënâ8€ÿ¯´ïp”ß-!ECG¥”»ª¶Úî>€“ìbÇ‘m Ù§ßã$\:™a­ª$¾œïŸ‹mñåë»°¥Úp•M¼ Óõ€f‰Jy¶šxÿş3¿y`,ÉR"TF'^A÷õş÷ß¾ìÆ©J6’f‘™ñ.O&³6û¾I•Ät$O´2ji;‰’¾Z.yBıÒ©vƒnù•k•PcPß#É¶Äx5.yoGK5Ù¡°öı„méû‘\øwş¨	
¯ á
Ã ‰ê]ŒŠ|gUÔ¿
„V5HƒëH?X\t)l’†×‘zMÒè:R#d3ÁUN3\*-‰Å¦^ù’èõ&¿EpN,¹à¶@f7ÚcÏÖWX„R‚ì¥†¾T)½tOQo£³q-{w¦+ùúu ¢ZTwçÓw+ŒİËê6¾«ÄgõÆRzÍ×T UfÏ»ƒ¼–†ƒlÙsÀVŠı¼]´,µŸmm³*G`óëØIQY~t[DÓ!mLø¨so‰Ä>*¾Ê5'ÎZn>{@Ø D	myXì£šá'ÇêvŞ²¬öœ**ÃZîßs0©MÙE”pïWßÉK1‡DwDz™Qƒ®'>ÊWŸ+„oZmò#¶8n‰;w9¹€UÔi‘›Ï